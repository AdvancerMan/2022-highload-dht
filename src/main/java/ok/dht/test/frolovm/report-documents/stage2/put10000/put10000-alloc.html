<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BEfDACKWc@y|APIhJppTLJQ`hSKKISQSMIYpXa`YKMJLJx`ZpJ[LKR``pRSLMKNKLIKR`hp]iG?Zxyq]GY^K`QhQ`ap`i`Z[JjpRYiphx`[KNJp`iSLJq`Rhp`qRp]KKLLLMNLIMKMTMKKH`xh`phpVLLI]LLULGUNNLNI[MNLKKLKKKMLLSIQxahahUI`SVMLKJZixhRa`aAqpp```TLJb`UMH`]TKLJ`ph`hxTLKKSJ`x`ZhahaLI`iSUJ`MNKKNNJSMKR`xhpY`h`iVQRSSLMUIhIqhhx`Hax`hJiqp`SKLMKLSPKKLKSMPpZaZ`pi^I\KSIi\LMIh`xhhpZ|Q??hqjhpB]Jq[MKMHih`h\LJppxVKJxp\KLLKLJhxhaSIpha``h`h`hxh`h`hx\Ja`h```hpx\KJhxpppMI`pyh`Y[MNSLI]Jy``TJah`iKKKNTI``h``ppph`[LP``ih^LJYapxSLNJhhx``hh`x`hUMLNLLJLKTLLRQhphx`xTLKLJiVLMJ[MMQ\LIhpxiRSLTJpxQ`a`xpULI\Ri\LIa[Jpap\LKJhxSSHpyW`ahihhKIpqJpp^MLJ[KVJ`hZq[KLNKLQUMHipxJ`hphphphJaxUNJYhix]MiO?DK`yhGCMS[PEKKULKLPhha``h[TMJyRhTSUKHah`ap\KSMLLJhpahNJpaxSR\MQhhxpVKLKSMMKJa``apYaa\Oxhhhxx``SVLMLMGhpaapZ``pqhhxKLKVKNIh``yhh`hZaihpZLKTYhSHiiq`YLKUTR`Jxxb[J\LLULJ`pxp]KMLMIqxKMKMNNIhhppxh``SSKUIppp[UJhpa`TKTLSKGppq`h[KKLSSJhhh`ax\MIxhx]KQh\MUJhhhh\LVJp[KLLVLLLH`ixahR]NLUIpUMKVMHVNLLPptO?AsLSP@aiqiO`hqpxYxpipph\NLNLNJxZqpa[Ixa`ip[KVKKKRhiUKTKMIipxVMJpqhTRpahhhh`ap`h\TNNI`pax`hp`xa`ph[KVKLQ`pha`x^LMJbZaUKTLJpaphh`ppphi`h`p`haiRpxxa`VKNLTJpxKVNIhphppphhh`axp``ppphphp`phi``hxhx`xSNTMIa`^TLKMLNKR`UKURh`hhip`hxULTKLKKUMMMKIai\KNLJy`x\KLKVJiYi`pahVMP^THb\KLLLVIx]LKTLMKQp\NMMMKNi@@\hpxAM\VMHCUSVITTULMMNIhqx^KMNNP`hipah^KKNVJp`a`ipph`hqxh`phhqp\NJiahhh`paxhhhhxih]KMLTNMLNLLLMLQx`pxyEQaSTNR`hhxixUNHxrLKTHyhppiZpi`q```phqhi`]KMVIxhhpixVLNMTJ`hxqh``ppix\MLMMLRxhahaLMLSTLKKNUMMJ`xaip`MKTK[Jp`q`xh`aaVNMMJpxpxpppp]NKTKSKKSLNTKLMLKLTKMSJxixpMMKTLTKLMNNKPx]UNJ`axpx`pTTLMi@HykNIB`{LMJ[NSVKKJyphi[KKZa``xxi`phhiiLNNKLQxxhxpq[IyxqSLNLTLPxhxyZphia`[K[KTLIxiqp``hx`a`xpi]KMSKVLMJ^TKURKSNLUQSRaqp`p\NULNIhxqp`hhi`aah]MQihpphxxh`axh`ax`ha`ixp`i`ppap\SKNSKKLUNLKMKLUMKUKKMNNMMNMNJi`ppp`q``ahxpp`appxphhhxxhp`pxihp``ixa````qxaxUKLSTJphhia`hph`jppELLTVIppx`ah`hixa\NJixxhhtO?`asLJI`kMNIZayh`hZz`p[MNTMKQ[K[LVH`qa^LLLLSMKNLNSLHhyap]Iaxi[LLRixhh``paqVLKLVJ^MTKSKJq[SNSKMLLNMKTMNKMLSJaph`qh`ihhha`a`a]NQxx`hxppx[Qipq\KKSLTLJqTVNJTUMTKIpapy``[NMULJx`hbhx``\VLNNHxphpip`p``iphix\SJhixhapCTTMJx`qx\LTJpxap`hqhh`hqxpZyhh`a[UKVKKNMLMKLVKPaha`a`[VNKNIhixxxSLSNKVIhx^TKLLMKTSMGtP?UU`x@UKh``QpcKR\JkLI[LNUTIh`qbhLKLN[I`q`b[KNRia\MIqahpp`hb[LLVLSHxihy`KUKNNMLMNKNUKJhayxJxiq`LNNNNR^NKMUKKLNMUKLJqpqh\LSMNMNMLNMMMLNKSSKJaihpphq]LUKMLKVLQxpha`pxaxh[UMMNRhhahxxTNTNKPpaxxp]MLRq`hahhhxaa`UUNMNJpxxxx]MMKVJpa]SNMLNNMLNKNNLNLMNKLNLSTHpyphh`pqxh`hhyhp`xhxpphhahxahphha\VJpi`x`ptO?QtLR?`psMJYVN[KIpM\R`\LNYh\KLLZhKTKTUH`x^VLJhphihh`h\VSMILVK\KI`xxqx`XiaxiKKNKTLNMJxhahiKLLVNLGxhai]MIpip[UJpip\R]LTLMJahp`xi^KMMLNKLTJpa`ppx``xpxxhLMUKMJ`qxha`TNKKTTHxxp`qhYihihph`aph\KSSLLLLLSQ^LNTLJ]NLTKQhh`ix[Qihp[SKUMMJxhhah`]VLLJxhpi`ph^KSMKR]TNNLHh`bpaWxapaxZxhaxaJpqh`a[TKUKIhaip```i`pa`ppphtP?KLphHPeLyRkQzT`VfStSgQhQ~SjSsU_VdSiU{QhSsP}UqVhVzUuUjUdQkWgW_WeLjV|QmTxWwWyW`XcMjXgLjNrNmRrUmVpW{LuMfNoNvNwNoOvOePvQkVuLaMdMhMjMnMtMvMaNeNaO}OaPcPjPkPtP}PcQ}QeRjRtR}RbSySiTnTpTxTeUgVvV{VaWzXpLrLsLtLvLwLxL|L~L_M`MbMfMgMiMmMpMqMrMsMyM{M|M}M_N`NcNdNiNmNnNpNtNuNyN{N|N}N~N`OcOdOeOfOhOiOjOkOlOnOpOrOsOtOuOwOyOzO{O~O_PbPgPhPiPmPnPoPqPrPvPxPzP|P~P_QaQeQfQiQlQnQoQpQqQrQsQtQuQwQyQ~Q_R`RaRcRdRgRhRiRkRlRnRoRpRrRsRuRwRxRzR{R_S`SaSeSgSiSkSlSnSoSpSqSrSuSwSxSzS{S|S}S_TaTbTcTeTgThTjTlTrTtTuTvTwTyT{T|T~T`UaUcUdUfUgUkUmUnUoUpUqUtUvUxU{U~UaVcVeVfViVnVoVpVrVtVwVxVyV}V~V`WcWdWeWfWhWjWlWnWoWqWrWsWuWvWzW|W}W~W_XaXcXeXgXhXiXkXnXpXqXsXuXxXyX}X_YfLhLiLjLkLlLmLnLoLqLyLzL}LeMkMlMoMwMxMzM~MbNgNhNkNlNqNsNxNzN_ObOgOmOqOxO|O`PdPfPlPpPuPwPyP{P`QbQjQmQxQzQbRfRqRvR|R~RcSmSsSvS`TdTfTkToTqTsT}T_UbUhUlUwUyU|UbVdVlVsVuVzV|VbWiWmWtW{WbXdXfXlXmXoXrXtXvXwX{X|X~X`YaYbYcYdYeYfYgYhYiYjYwfOZZZZd@ZZZb@Zd@Z_AZn@o@ZZb@Zb@Zb@Zk@ZZb@r@ZZZb@ZiBZZb@Zb@d@b@k@Ob@ZZb@k@ZZZZZZZZZwCbCEd@dAb@q@Zb@sCZr@aCZ?E_AEZl@d@@lAZo@?Z@F~C@ZCpBZb@t@Cb@N@ZZV?HZFOo@n@r@C@VN?@d@MZDt@@EMDdAZ??DFZZZ@?FFZpADZ]\HNEOq@Zd@EZoAF?G]b@GZHb@CKG\l@?F\@ZZNUZDZClAZ?ZFHhAAV?HZZKAZGMC?CpAF]ZMHNACKTLDUZNPV\d@@@\AIsABhA??SHH@CJ?UD??CBEPUOJZNFSLECALNDDTSSd@AJSFHC?@@G?NZHHE?H@BBEZJUfFoAt@ZQQQNQTQBQIIQIIIIBIIIIIIIIBBBBBBB?BA@LJ@S@Z@UO@OHFA@CGDGJGRCPACZCDAADDJPI?EI@UVJSQ@F?K[[TP?KOVn@A@RMJA??QP?NHACKKPOq@LB@@]?S@QKSQALKHN??KEI?@D?AH?OA@UtAZ?K[b@FV@F@OE@L??MA?TDIK@gCU?LIIV?@ZP\UBUINRDP?IOFKQEGDHFF??JJQ?JCBNLd@[PCYKMBCDTMPID?g@?OET][TG@Al@VU?]@@JANYA?KVADNFDOFFM?EANGEH?E@@GLNVVS?FI?LGSUDHLI?FCGHPGZSKE\D?JvA\UBVZ]\GYDE]LTGHGi@?DNTYPXPE???YCLAFJQLQOKAHRSKKYZ@GCCDCCKBT@AUJ?]ZBFJLWAQDBHCFN?BEIC@FJN\W@WODEAPCsARSJD@TTUOH?SOAPACHPGCSFRN[XS[LALAFI@@DDGIBIXN[?O@CE?R?CE@@?CBFNIYFW?V?XWGAJ@EF?DBCB@GPPJPVCI?i@FKHYZKUCTD@TUSSENKHAL?KAKJ?LFDUCCEFRHXWVBE@DFK@OGDFIJ??EAB?EK?TS@JBTDF[LG]@??LGHBGDCMg@SCSNHDCL@LDSHOUJ?IXOPWA@TD?MA?\MRDPXYI@???LKF\JAQSAW?BMH?UFK]AMRF?[@F?EOCHF[CH?@K?BY??IW?UWWFMGX[BN?SA@LLQKKE?ICtAKKLCE@D@FKMSAXEDQK?ZVPEKXUDFFV@YAQ@AFC?DV?EBDANAOG?YFDER?QJF@]YNA@_@WTE?VVPW?DNEPEBA]CMBAB\J?D\EXBFLURFU]TT?EDDZ?F?[\@GPJBH]R_@?CA@LDXPID?PMXLD]]EXMA?A?LGXP?F@?CN@AJGJ]IY?D[BKH@RKA@ND@GI\?QRGSRAEGUTNLFIL]HXGWGAIB?LIG?\?KRBLMF@NAIJFAQRA\\CLG?KS?HAN@OCEWCBUJDWLTTLCFAAKMYG@ARIBBQ???S?JFTPGDLO[MHPJQ?@?JXTNB?BOKCYPPTUC?_@AQBFXVCD]OUHOJR?[DFRPCD\AGWGX@TG]PGPCHO\LRMLEVA@?J?FE?BTJCHZABAJAJOFB?ORH]@PF@SWXRGKLA?H@YHEFO@K\AIMDCPJAAUECKKTJJLV?SAFKC?PWB?YN@TV?D?SNC?RYARCKKXPI@SBR?GQ@FJ[@RTJAARI[BG?RFDDS@ND?ORPPK?CULAWAJ@FSCJBFSCFYDO[G?OUEGSORJAAWE]PD?XBDPO?JBBET]GOWMFSOTUR[SNLCGJF[RK?DEE_@?J^@A??AMFJB?SFR?JLBLG\PG]ZWL]GPB?JNKS??Q??DXCYTM^@B?BEHNV?JJQHF@EOSCL??X_@GA?LLFMPMKIJKGMWXL@TETASOVN_@B??EZENCHHQI?E@O\JQAJF@[DTY?^?IIDX\ACEEC@FAM\JFJJCESCIDM?TBX\NGSE?HCISF?TQFWMGN\QIF?C?RJVF??MDHCOBEEFLILFNHO?TYFCW@L?GJALFHDMIOKF@HACL?HGADT[?CGFKSCHOXQ@L?L`@IIQNQQQQITQBKIQQQDTBQBIIIIIIIBBBBBBB@NMLDQLHHS\TLF@BQCWELMPGO@C?G??ABN?NSAIPK?TQF??_@FWVXPX??GLRJDPPMWH?SGDCNEN]FQNFAO^DKQEQ@UDEEGAGCMSUF@Q@BIBVIFGDWRGSPIGKUVWLJHDA\CCR@?DQL?DFDT?S??HCJDHADDJ@AVNH\TEMRA[J[D?TKOBYB]ADDF@KEI?]RJ?JFSMXIHH@XEJ?P?GT?OOFISBFRCHEYYXJNAMO[F??JCWSFRPEGCEFEFKO@QBWDM?WJ@GJEDTKGY@CDNPWRIDBC?Y?BTYKXCJJ]@A@JHFBO@?FDIOEECNAI]PBHVPJGEB@DTBPC\F_@X\OVCTBFMBMGI\E?MHJVKL?EHSM[SHIMCLUDXDLXUEMAR?CKBJHHHO@TFM@P_@BP@BAVF@S@GKH]F\S_@KHGEEED@DBAOY@GKMRQPL??JREESJ??WXXYE[XEH?IAEWBCBF?SM@OGNJJFKA@UGO[?^B@S^@AH?HAWLM@YRPA?N]B?PFJXVQ?CBDLEBTCD?ADJIFAHBK?L@YKMSMFIU@?PEW?@XD]MEPR?RCQYTABGE?XQAQDWQFLQGAEGAGP??WILYMAD?D?PQ?LFFFUCBOIPBOWXTERIECJXC\?HJGEDNQA?M?@JOLFISFKXMNDD@AEFLERDIH??@WMMO[N@?NDFW@A@U^FICXSPM\AGWHRE??AU?[Mj@DAE??T@?@FU]ASDA?PIJ?FLIMVGCHAHIERFD?Q?[TEMJ]XVPX?RLEU]HH?SDKG?CBKNDR??SFJG?VCDJ@]@@QR?CQWINJ?IFDG?OARDNHF@h@?AVYSBUVI?V?I[KYXGOOVYXBPYRAGAAF?DWC??ON?L@FTLU?\KDKI]IA[@HE\NVOYJEO@H?BFAUUDBNELCPLD_@GEXHEO@?H\F@DS?Y?@PKF?[SECMFOEIAKXLCMGNO?GKLCMISUJFLYJXNLAXC?DJ?TC?HC?[L?D?DTKCA@@CTEOPRI@^WFE@@YEA@E?XRDIDAQK?@?_@???\HCK?WDFTFQSMO`@JYUHRPMPR@RGKGJ?FB@RCTOICVK?VGD?ED@[@UJA@M@CICGADPKO@JQTVPAECUKFFEIOTTPA?@QXAGDWO@FGC@H`@B??DV@YBABEMB\BET?TSVIRAGB]YDE@AQPVT@M?@?REIBJJ?OJXDECQOBLDEA?TB`@BN@FJNAEU_@HQGAEN]?JTCIFUAOV@AEK@?REHJB?CYB?C@?VNWOIMLXF]U?@RI?DRHQFRH]Y@?THS?EEMBK?PDUKj@@IP?LAJN]IDSDGCGJELVWWPATN_@OA?[YOCAAQM]GIH?LGDQA]WBAHFMYHKW@G?EC?MQT?KDJGC@HB@@LJOTEF?DL@DG?OJENKCKMQEXYD?WH@KJ@KDC@W??K?W]DTLBC?OEWSCESCDBNTUB@?SHIH?BLDOP\TKWM@?CAHVKYLP_@VQSDLHMH?COFRJNKFDPXCRP[SIADBCVQJNGIHURLAU@RD[TB?EMLMJCKBNASLJNJPKJ?FDDMXBKXIRJ^YDENFJLPKRUJB^PHA?DCYKJ[?]KF@KORDELIDC?W?CFI\TTCOCM?HTR@?GD@S?a@LJCHHGUO@P\Y?F\BCLCRI`@NUKDIIDJU[Q?D?NOCAF@KEUJO@@@?BE?BLHQQQQQQQQIBQQQQIGIIIIIIBBBBBBIIIIIIBBB?ABEFSSYQSF\LMJCBDP?@GQOUBDHIM?DANEBMH?MLF@JEATJN@H\J?CWSNCOOHF?A?A^A?BEP?AK@?FSRBF@@QX@JIG@ABMFEBEW??C?A?NWMDAKL?UHFATAMTFS\?H_@HJ??T?BKOP?\\?M?F@OVBI?BFRM@XS@YCKBAHBBFDDSNEGJCCUFDj@Y@T?AD^NNFD]LF?I??ECADDHTHD[VOQQF]FMHA@NPO?FM[ATTMLJCPADNB?ORDP\L@[FR\EY?BHYOE_@DKF\GYJKCJ?Ca@POIUUJFG?KNVE@\AODNJIJ?\QN?ABJEFTOFA?MNLPUONDDSRMEYUE?LT?S?XUE?EBQUC?FMYH?HTOCMH?BVEB?CRSFV?Pa@JLNH@FEAS[BT@LVNIMH?M?GS??ASDRCLUIDBCRVF?DYVF[DFTK??IGG??\A?FD]OPBSGPMONFAUWMQFOCUJVF\CKGIDEAOMFU@AEHNHLOCJUJ]I[THECG?D`@@YLDM\OIPSF@A?QKH]DBBRFA@?EAQ@VMFC@NHKR_@WH[AHYQNVH?KCU?KU[PPAHEUTEVPP?GCYAA@B?RQT\A?SK?PWRET@R@M@TNGEWECNOL?AGH?\DNFFEPUEJJEVNCDRJOQ@B?@?G?INXGDWLHMANMGGFJDSW\LMFNKTEA\@[GAIK?ECLL?G@H?G^P?BEGHWSL?@X]C@GF?YFF?S??TNXP?GBB?D?ACF?RFGW?G@QEG[XFTXLEIB?GQCD]EHM?AKEA?FEAQNXPR?CSJDYPSL@@?CEKJKC^@QGCIHH?`@MRALBODFLSJ?@R\T@FCCAOYDI[B\DOIRIh@A?@N?V?B[ANHVFFYIBPFFRA?YP??CUK[DMNR@USB?HEGA@S]IUID?B@HWHYN@?QE?JKWU@YXQI?PN?A?@BDB@EDHJ?AGREJHWXLYPESE@[V??JL?NCF@PADOYA?R@?SP?TBRKKJNPDBKD\J^@EWU?@VF?G@AEQRL?SGM?MU?BEDERNEYHJK@HG??VSLLEACXTYNJXKMHJCCPKH@?N[BYIPBINCOW@@@?LETXEAUXAILHA?H\DUENOC@F?E??CGAQKF[EAJJFFU]NOYOQOO?NT?@ONEKAAK?I?CDU[?TS\JIJD?WTFI]HMFQF?EKDHC???ON?I?GMCU?XVKUTFD][LWSFESGCCD??PIIADARRC?@ET?E@S??FHQB]SUFVSFI?I?OOIG?A_@DBD_@ECO?@M]KFCS]UFDXGAYUGQUVDBKRPCH??KAR_@H`@D@BJFFKTEJ^@SGCEJF?@?\SED?E?CDKIJ?PERM?B`@YS@TFDT?TLSRBSGK@@D???DRRSKFJKD?TXA@YAGAC@QMR?YYDC?FCUHW??YMCH@UDOHA[LKFO?B?KJ[_@KRTKIAQAOCFQBRAJJ?VE??CJDFJFOBQCFG?QDNC?CUDDN@R`@PFLAUJ?BLDI?LA[OLWD\V[RFMAAM\EOC_@IKEIQMH?GKSQVE??QS@WF?JHa@FHKTPVILDMDEM??M`@MBQPBTBHMJ@BJSJ?TP?YECLSO@FF?G?GNI[EMKIHLJUEHRCTTRLB@@GKEV?IL@QK?GFM^OHSQ@CFAMXAI??LDHHLPYRJPI?F@JBFL[??T?GEV?HRSKBQKL?HL?G?CBH[@JHDOTVUDXEDI\BFB?N?FRMP@??FBKLMHILTDRLSHA@HJIAGIC?A@EQKWPCLCRLK@CALCABSGWJBJ?WAONDEBQIRIEBSTQQTQQQITQQQIQIIIIII@IBBBBBIBBBBBBBBB?G?A?]G@FMDFQUS]XOHMFGMSU?SEE?D?BH?GRAWCRP?W]FHESQ]MQJ?C?JDSDX?KGECBRBBAEAK?L?E??[@SP@YFU[??MK^RS?VEFD^GEC?NFEAROC?Y[JHHCPQVC]]S?GPKWC?LBC@BWACT?MF`@DBHHPIL[HD@EXL@F?IB?RBWQ@F??HVC?AUGHMCPA?SQID?EHLL@Ja@QSOMLQNLJ@?AOM\GCNCA?GCN]FGBEKGGMIF]U]KWHQH?VKLKGB\UINEGBE@LD??AD?OHBESVEYF@EVOQBHVZLH?OVO@W?LR?EOGP?KPDGUDY@AUQAD??@A]CSOFAB?XFBBFDGAIEAGU?Y]?GWIW@EOCCG?CK@J]L@?DDEEQDBMCD?DC\HMJFTATLEOHAPHMAFALJFQHLEBOE?J?UER@H[PLIEDMY?DQPHAUNQU@PA[KQB?CDGGEIFXHW?HBXJYXXT?O?GGG?XT?QAPCWRMCDBMBAIKJDDFXQWBTY@HCEBQSHJOG?MM?ACS?MBENI@GDNETGATJTUXF@QSF?N[??DIBEOEE?R?SDP?BQOGSCFW[IC@YL]TE?JTCBROHKNRHING??SUBB?c@RCVNFJB?U]L@J]UMM]BREHGCDMHRUI_@B\Na@DNA@AFB]@\?@UQIJ?PYB?Bc@DDACFDPNWC@K?MBBRQLTJFTPYPTSORA]R?B?DVMEB?PAMDTCUJ?CDB@JSNBMUQ@CKV@D?CEES?GEG?GLHKM?C\DSSJMFCWTETKCW?P?FTJ?EPHCHH??OABV?MP]Q?F\AF@PANBJGAL?ADYFFEM^H?BH@ED@VG?B?@KFBSS?TOSE?G@EI[EAMVWCBDACC?QN]QBNFa@KKM?SWFJ?CEUNAOH]UC\EATHPI@JSEIOEEDYI?BB?Y[]@ULNI?IXA]?D@CFDE]J??LEMRHCB\?PE@OH?A\E@\QJE?HEOQHBAF[OAWB]RCBOJAOCNNFGLC@FQS@BNNPL??DAWFEEBOJVFHRDPBU]?BSH@]EEVEP@AGQG??K[SEDMBN\NI@FEAc@[AID@FN@IY?KBCJUO]CXLBRAOMBRCUPC@L[ABLPH[JFa@TOLMEBHJDQ[WG?PN?K?@ERB?GKFAEVFFINPUFLEANGFSCFGTFIKG_@OOCHFPDOB@P@UBGJ?IS\ETLPDFFYWIA?CNDABDEAWIOEGUOXAFBFIKFRNK\LT@TQPO@DEADIKADA\PHBHMMOF`@MS?JV@?U@D@?JFHRHFHM?AEPHAUDNG?C?F?NRC@R[RWLWGU?TJ\E_@OPFa@C??@IEGHKH@IIBAPAOFFFACQ@Ja@TLCTGELMM?ENKFH@AAOGDUNE@BSSNGFE@?SO?]QNKHUBX?CNBJDEVG??XGDF@HBIL??IGFWCNOC@TWXDOT?EHEP@XD??AN@QCKU_@MJKTFDAMN?YAD@AGFTBABKELQBDP?@@HGOOIJCGFF@?MMRJHC@GJWR?IENPJTLRUSDC?ED?TQMUKUBRD?Q@Aa@NDS\?NN_@SBB`@TBJSCPNDBA]\VSFC[TM?_@?BCRDS?HWPMEJIC@Y@RA?HECCW@RNS\SLAF?BBA\PBDKDFN?CB?VUF^DPGM??JD@L]CLWV??@CRK\EOUOKWBG_@?JOGFJKGGPGF?V?@J?FKCL?RRR?QMDH]\GK@QFE?Q?OOGF^GE?B@XFDHQLKBCAWGBOLOD?OJBHTWNC?\AJCYTJCPFIFEFKHAK?B][?IG?OEAGL@OXDYHF?XGFAJBJSHXB?HLLMHCOOBER?KF??X@A?YAMOC\@QMYFIIQQQQQQQDTQOQ_@QQIIIIBBBBBBIIIIBBBBBB?EBBOB?YCJSSAMFVXY[X\V?EDDQAMGKKE?GNGBNFIA??WDHTJAHHWBLFLTSD@LDRR?BB??M?FJ?DG_@GPMITU?GJHFQXFFAKQ?SLYRMJRAOOPB?FPDAN?EMEOC^ZTQ@NL@F@Q?LCTRHBJJER?FN?@BDCHP?N??KPFAV@CRPYFXF@NNLMCGUHMA]EHUA@ERGE?KDM?@B]K@NNEYWS@?HDEFHHSJEPLKXHDKGIMEG[ETBQLDHEQDH@ME\RSPRLBDFD?T?]DVIE?KEE?J\YMGMNMJO^OVY??UAFNANWPGD?VOXSIFHD_@OQWHVc@?ERRGFF@?DND@G?L?MBDPUJXCANHSJG?SJ@HCCABENLXJOPG@O?DC]^DG@C?[GJQDW@DADVDJD?EDA?]S`@@?PJ?GDO[XY[F?CKA?[CHOTDUWJDABHa@DC]_@\LMS[R?INDA_@S[@KNH]D?UV@@OEABCAKEP?AGVX@QAM?MASc@?F@FABYBDSEUGVOGGCEG?IGHSLF[BCGKGADVDGVJI@OKO?S?VPJB@ER?EB?CNJFJK@TEA[AR?AJXAHHQ@BKJKDSMAL_@GAILCHAI@]KLJBO[O?GMCFJGBA[ECBTJKIDFGK@KKFHAUVDFSGACDH\BADL?KOCFDA\TDBFAIXFCVNCOXK@CHCKU?OPBS[OA[a@UHBMMA\JFIAQCFA^@DU@KD?Y?JKBPH?TRDVVR@MYB^KOPDL@DGVTGBFYNCLJ?PBCE@D?EB?@BTDQTEOEAHCPBSLPK\ULBBFYFIEAEUGR@PKG@?SGHGPAV@IBC?@PFMR?AL@E@QKPFS@OEAO]SBHEIDLAPNPCCGAKVBLKAUN@?TDSG?HLB@@XVAMKEFRB_@^OC?R?RAX^KJFQSNMSMG?ME[QEFFO?TEW?HFC?DMGKKBHEHGTGLU?ASJCAS@G@`@CA?YA?M@?UUFDMA??D?OEJ@DA?T@FWMSPJB_@\?ILF?XEO[KKCFPGCD?ECHIMQUIHQT@JCPHJPPAYGC??[JU]E?DFB@BIAG?NMA@JGMSGTMJ?@?\CJCC?CVPRS??A@FRGB?EOUVHSE?MIK?HS@TJVPDPATRHMGFC@?LPESOPPH?AEQh@HETOLV?PQCX?NIA@?KEHRJDUGAC[BJR??[LD@FBIWWH[RC?TCAOEP`@RGDG@HVD?PYLVO?AC?YUXBL@OQIG[II?WG?D\?I\KPG`@IAKVFJND??WF?RET?WS?BJBE?AF?BGN?Y@BBCDA@XFPI?K@?EFDAUC\JF?FPXH?H]EPOLCFDDGIB\PWC@]ABKEMT?JAQTKHHJ??@IAKF??LVRKHMB?@XBGUICGJLNHX?EOSB?XE?@KB]?a@GX@G@ACAGAMSWOAY?PVAHXBKMFY[H[N?HKHJFMABQOMEYRO?CLEF^BMMFQ?I]YFDPLGUM?@PAN]CBMDUM?I@?DDNUPNQLD??VA@IUIKLFHSX??F\NGBE?QXP?G?P?Q?BD?@I\L`@VN]D@B\@NCJLDGGMBVN@PAP?D^IYACMJGRRVSP`@ITLAK?CY\RX^@GA\@DC?CIBN[G??T?ODADWJSMDA@BBFFDD@OPMFJ\?GR?IDNBUg@?AJBPSSMJLD?H@[\R?D]_@_@JALGIQ^G?AHAB?WKNKQTNLOPQT^][C?I]CAIF?C@NMODATDEUBC?CRNHLM?XXFTLFQAE@OSNG?FE?@DBi@RLGMEGAW?ECF?@DE@AQUVD\N?DH@RYDBQINDMGJKEFMNIAIF?MNUCDE@FSKJ]ODRIN@J?G?FA?@CJ??BR?LBMBLXIPDCRVLWJCK@BRHD@KDEEQFE[A`@`@AAEP@D@@_@^KM?U@J?WERDWIN`@EJBQQQQQ?QQQQ?QQIIIBIIIIIIQIIDIIIBBBIIIIXBA^EARBDB]@TTVFV?]WSIMJ\KEBHPPNABMRGMX^HN`@?RW@FHFFU@S@@BDVCSOFDAIHI?GD?RK]IUCDNEI??MDCQ@TFXLQRULLSANPPDBAPGMHXNL?PADKCPPPGKHSBS[LTMLTLO?VLFEOBH??CU[GKMBBEHHGJHHOOQLVF@WVXBQCEJKHHA?CDU@QOAKKICEE?O?_@BLPSI?TWWYVSST?LWCEAAIIA^GCQ?O?IS?CGGHAD[F?VULT@F?GH?S_@WS@DPBK?QBMORAA?FW@A?EEPJVLLALUIOK@LFLEGGMEKAC?GWKKIEI?C@ACR\IS?D?LSJ@PL[EKT]I@DPBE?IMHY?PSHABXPFEHKMHB[CWLA@?ER@U@RDUBI?BAYO??HNGAKF@SPCA?OS?@R]JPF@KJDS??CH?MCGDKJDQ?RJCJQHNRCEEEJLSQALQ??LM[EKROGa@D?XOHASFa@UAUOCMKEPBKBF?\[Q]RJJB?CCEENHB?JMAV?NAFO?AVCL?Y?XN@MVE@?CUJNI^AEEHKENDF][YO^@?AEJCAEPBM][@AVQLY[N?MMBCBHPa@N]KMUE[QYABBU??TAC@?VBV@FO?NB??M?NGA?KCW@HTITCUEFP??LJU[IFGQIVAHCDODRAIOMOE?IF\FTBAABFOBIEDYJJFAXN@SDT_@KCHBGOADGCQCQF]GYAE?@BSMKBRLEU?G?F@OYNA@EORIH?FSYF@R?ABC@DUER[GC[CK`@JLGFCYON?Ba@O?HPOMJWT\JACEEJCD?V?LS?FFFC[AFHDR?M?AHHPDO?NXYFLFGSP?SX?NYRDHEJQHISC\NGKDDA?GM?NULQV?RRJ?O?L?V?\GUGJRGL`@AXRT^?D_@G?N^PFJ[LA@CAIKCL?RY?EPLHc@JKD@E@TBPBPD@EMD?]V]XKIAXKN?RVRPMQTOOULBvACU\HEAAEMUI?]SCVJI?UDG?EOJMc@APRA@@LFAALESD?HM?M@?VHSCGXHNLHJ?UB^CGNBM\HDQMAYAS?JGC?AC\REFSUGEBDL@?PN@B?EO?FMUJICM?@CC?TGIG?GFSBM@SRE?@[?G@ERN??K?J?LU?X[ERCSEsGS????JSBDVSAELPFH@CECABEOAOVOD\FXOBA?EKLD@TNC@?VYBBKHFQPNGPDD?MFFO^M]AVIKRACFNFRFT`@?CN?CSVXOFPBM?YADQ?K_@ISCYRCGH@TUXHACMGGJA@Q?NVBWO?JNGAP?ACTECAXCJP???\\LLMCAX?QOQND?AUY?KPG?LPACFR?LNPKDJGGG?JF[??MSJK?T?ME?@S?CANSFAMKE?\I\EX?O@SJKHDOPJ@RG`@DEXI@F?H?B?AQHK?P@PYFE@NFD?[TERBLAFCBNMU@?NQARPi@UPDEOVC?@QYFMC?Q`@EF?@P[BIBHH\A@P]GDa@?PCDXEOO[CFS]CBAJM?[@[B?DEDU?KRC?FYDRARDF??FNOUE^TVDSO_@Y?JC[H?B?BSIKNEH^?@FG]?FAPCTLBVQLOGGT?RQAQNGIGHBBFKMDEERLQD`@HVYPDUIAWYQ??@POJ[CJ?ECBC??DA?A?TEL?D@XASEOCJC@\BXYIFEMOX@HEDEGI??G?BPFR?FBOWVLJD?VU@JCOFBMDMYT???HOEE@ABFPSLTB]M?CDANFRJSCFDWNN??DQI?CTM?EYH??JF@@K[IPBPDHDOLV?@RQ[AQRKBDIWIG`@LOMEE?Y]RX@FB?HOUCJ`@@?H^VMJ?EG?CCOMFH[RIJRDHBYEST@K^?RJFF\NT@CD?PG`@N?GEOC@WIO^O?EDGFYBW@GUED]?@FJ@F?R?OCC??MGCPBFW`@IJET@B@AJGFFD?THBNWL]NIDKBOMBGPG??NX?CQQQQQQQTNQIQIIQ@IIIIJIIBBBBBIBBIIBBIID?CHAOM?DHD?R]FQLLTSCX]TLSQDN?MHIBC?I?LNCCAM?RGPP?YY@QTU??SJCTW\E?^OPI?EE?ONSBBHOEDR?RMMJU]]@U?]UIFFJLE?BEBHNFEDCEDEF?DKCIPWDLF??UJAT]@@U?HI[?MDIMPRJEASH?OD??^UHRFHPIJS\GTTTQFMDG?ECGDK@E?F?PB?G?NGVNTEFCUJF?V@EKGVLIUPEK?A^G@KSOGRCAM?A?JAOBSEXEW@UCTWCJSMHHDB?G@OUI??HE`@BFB\N?AALJ?@ODSCFAT?]@AJV`@IPLA?ND?G^?NFK?FEFDOJIWCUDVGAWDGTDFFB??@IDIGJMCBVA@AKAIEFA?\?C?LS?a@SS?KD?V?T@I?QEINFYFD?C?ERAB@PLAESMNYIJI\F@_@@OMP\HARGP?I]R@WA?G@EX`@CNBKFFGO@\D`@BLNNS`@C?JHEAB?SAL@MDMYR\C?V?IGYR[FNFP?GTEPFG?UMIPPMA@RAEWSASD\DEL]M?HFLK^D?R?ELLBKC\I@RAGJXD?WKCFAEGFIMVKTD?D@[DB??]RDU?@?^K@HF?DLAOGRIS@EWQ?H?SRQDHEB@?CG@CA?UEPDEAGLMJ\B?TNP@ELKFETJHFDHEG_@@O@F?RIADBHO?[ALJGAKTYVHREBEUWDWDLa@Aa@N[?@V@CNGCA??IT?IEES[E@@BDLB^YPB@Q?SND@]MG?FIIKH?TCHIGYANIJJJ[FDBUOAYCC[JO@RBEKK@NEBBJVCCWM`@HA?K]JEPWAFL??K@@XK@RGH?I?P]HKDVCCGF?ORD?UPOLB[IJ^NLPLKUJK@DPKEBMKHQ?@?PHYCKCW@QJQH?HO?@?HCK@VSJ@MR?R??QE@BC?IOB@RPF[IF?NKE^VEGD@AVXQI@[FLACCDDIGEBWSAGIGAg@F@VHAAHWCBPCB@URFFJD@CA?RG??\O[?CNE`@NWWH?LIU?CBEHP\F?@A\@XY?D^???BQBFPA?TFKIFA?P?[EHCDFKJB@UFHVBHNa@@H?FCPTPLFB?HXY?CD?GDXH_@O]NX@RJQM?OHBKFP?GNTEEJCJ@?CUEHWDH?ENFEGWT?SF?@BFH??HJGEMAFHEVGJNMAJCALGPN?@@@JEKIF?JNIBLERDYDRDAGD]UJXDCWCB???AJGF[@@FHRCTGDGO?XCHAGO]CN[S?RINLPEDAc@DJLCC?T[@FKCVISa@CHGMXNADUOK?U?EAHF\A?KEBIY[`@WFALHVU?NCGHAAAMLCVLRCI?CV@CEC?MMGY?N@HXLYMSXY[PCDGA?CH?QW\PCBWJA?N??HL?AVELBGJJ?MNK\CFP??H?^?FQ@B]CK?VJOV?XHCALIUM?HVCSGLD?HUNP`@B_@ESNXLXRLa@?UNBEBSHDJAPP\?[EBPQD?RTWCMHJRCJB?AHF@U]?]N?MJ?JLFRAEIF?NCTQOC`@?NQK?@CMBF??T?L]BME@CQIGWI?LPNDH?WDHGLJ?_@PJ?_@BQ@UBFO??HK@BBQ^HO??@F?^FDU?K`@]JCEUBA@BBVCL?GVAOOCG?DRLAEG]LTDKQBGXWG@C@GJP?QQMVD@?D?IN?KB?_@TC?I@FSPN??AD@TACU?ML?RMFY[JKHCKPBRPV?KBF@J??B@M`@@??M[?`@?JFSTNDPLM^\XBB?[KPKKMMTJAAJI]B?TNEIN@MFNCJE?[X`@BOFE^FCa@KBNQ@QMO?GH?HX?AVIN?JAY]EOHJFFQGREUIBDEF@@APHDKFR`@^R?SBDAJ@?IEJMNHBJL@ECVGETBQR@@PGQ\EIPHA?AJ?QOA]MNEBA[?LMXLJC]HOHK]]?KR@RLHIKLE?JNEPTF?JEBc@FUP?JP?NLCCL\ITTRPQA?IHBUG?NT?BHGCWI@NAJPC@AIAC@GNQc@c@TQQQQBCQQQQQ?QIICIIIIIBBBBBBBIIIINI?BHMAEKRWM\XJTWAWQ\@[@WMNKRR?BGIOONE?SDAE?NA?RWGELW??@`@V]@JT\FCEM?RG?NKECOLJIP?MO?IEKGYCJJX@@F[LQFKRBHARMGD?ICIACF?E?HBEG?E[X^E@FLUQRV\EB]QTGBI?CDOONAV?GKOM?B^DOMX]KSQFGKFVU[VY`@?REGHNNNN?U]G?HH?PBDKNHFCU@PJYY@TN@F@QH?DOEPGK?NATUBDMBINMED@\?W[DRVLXU]??[NAHEGMHBESLDNOMG?OEBNEHHO[Y\XF?U@FRFLH?D?ONH^DAEXEYS^GRCKANPDC@WFXVDCLJFJAFBAAOAPKC?EGHEBLQ?GHCHCUWSEF@HAFN@JK@UARAREGKCBHWMCBJDJNDOAJFQFBFAECFUJWNAMAUIE?NEMJRCGCQM?SCENBNRBDKW\\KNLAO\JSVCOS?DDDFH?H?@EFA?Tc@MGC??HOYQFO[RIXSPSDD]O?HEHCJH?DGQ\DXDONGTCGLQAGSH]AWSNC[AMDBB?R@NR@EHQBXUBECA?C[L@ASY?EQSOEH?CFRZCPAKBMLRG?LLFB???T\FNNO?NTELK?SLWKBNDCOU?`@JAKTGGXBFPHPDMW]@A?EHEOBJDLW@R?TMN?AKF?^KO?Q]@NC@CE@JRDOCDKKU?Y@ROFGRS?]CPCS?DAPFSNJRBAEQ?NVX??G@@FEPDE??@PCHFEMEYCAO?SF@KO?[CFJBC?CIO?L@AFBB\AKR@??GAAJBDMDL[JNJF@?UEDOHDELEFFPHCKBU?NAAJOCGHOAE]GLJG^DT?]SUCRECPLFLCBALC?EQCAG?RCOAE`@X`@NcHSUOA[YYVKKORCLVF?OC@CEKQENADRRW@?ORAH[FB@?@T@MK?MBMO@\D]CAAAMUBKELCRMCLDDUECW[\FG@OBRAIPA?@T?LNHNQI[PO?COKPJH??QDa@C@FSSBJRQ?EJBC@@[C?LBEGGFNKIBAP?GD@?DMLPOF]LQGTAG?DLFWDC@OBRQ??DR@?GRADHLOHTGC?TUKQSDBMW?CK@JYEKO?OSG?BJPKCDF?YAAE?CBVUYXC?HETAHIDAJ[FBGMHSHMAJDH?RFHABTEIN@LY[DC?SE?CFJLA]UBD?HG\EPCHED?AFNF?NORT\FA\?`@AGLD?_@GNUT@F?[GEMAB`@?QPXD?GEBWCT@LFDA?EM?FKT@J[D??IAM@R??BEEVPYCEM?TH\@?QCGP`@R?@CHJ]LJ\D?@IEIDPMDXCH?TO?@[MTJI??I?KE@LMSIMBJULMK?MDK??DBBXE?QO?REL@J?FIITELI?[WLKLP?KPHEEOARMG??FB@HHAAYTEXAVVWERBLBW?WBESE_@GGGHDBJCAGDKFVACJQPEUUCOWJJ?@ND\PI?XAIKAGCC\EEGGDKQ@BFF?FKAU?RLE]FBITU??EL?GCENBVOOEHMKUNCEXWTTECEC@EJDSDVRFBBDR\K?BOO@???R?CTNYJ\SB?AD?LAKJG@UGEQMEAFDAGAH@Ea@GGH?JNY[HXTBJ@CFD?KVQF?NIMEJPCDLIAIP?ELPCOKUD?YVFVEHTHCRY@_@?QG?HXKIO@IEHFO?DEN@K?ITLUTI@EGJI???PM[FCAAG@?ASG_@NF?I?F?HIh@JIFHXWHB[GQ?KMLD@N?AALIW]?EMGRyALCLMO?APUY?FIGDFPHFKHESUID]ODFGT??ICRTERT?E?EHHV]HJCSU]TAOBFEWC^\M@LCPB??AT?HC?@?ERFCW@^IIBFSAOQDDTBCKEQ\HTACGCI?JODIQXOQIGEYPN?YILONUGSPIRE?KEJFN]PKSAIM?SSPTSG??IF@V_@QKWHRE??OIB?UEFTG?N?V@DEMJW@JA?LE?EEXVN@INDDDRFE[X?F?QQQQQQQQ_@QGQIIIIIGBBBBIIBBBIIBBBIIIQQ??DAI?RNBM?OI?LLL@WSLU[FFBV@AAGBIP?OONFRANKRRABC?Na@AC@JF@RYJILF@\?@MEHN_@DNJONN?HGMHMAPMI@ITQ@LJT@SW[LKGB?OPG?L?ARCAIPG?@BMN?O?RQR@X@@EEA@L@TTPGHBCD@QAKACREJMNR?DADCKSH?JQJYC@@@XNLQBEOHD@C??DPFWEK?A?EMD?CVF`@T\YRS@W?QCGEBBNWPN?AXYLOAKDCDC?KRIRYLHU\V@VQDJBFCCHBB^AH@CHARU@BOIBMG??@@FDTGSAETNL@FDX?IAGCJKHKA?GXTLCNGCDDOC?AJYJLM?@J]MVU??N_@R_@NJI]?HIALIDKADEMODF@JBXBG??SJJHS?JF?KRN?YYHH?MUBMRCADD?O?T@?AHUESWD@F\BKAGYGRCD@CCY?HR@PNP?BREAUJCUDKY?@VBSF@?MWCQ?EP?J?LAOAIKB@BAASFHFG?FLEKMHJL@DQLMRM_@PE?QCO@[B?TDPCKKGEJD?U?A]FREVLV@CXFMBDCU?KURBICBD@QMGa@AEATJF@CEEIJQF?FQGEUMR?CSQOBMIHEM?DFAOWECI@Y?BQGVDBSCFFP?\BBAWD?@TKMC?CIHQFEA?EOJGQEN[[GP@?ILJK\OKLMD?Q?\MRCNQP@FRCBKBD?NQE@YAC?Q[UG?^QGUGCGH@WBHKWFMDCHNEI@ACDFC]FJNJBM@JCMHTBHNKAJIFEMESXCOFT?B?OMR?OTBEQOF?FXPN?VGGBFGMXE?KAEC?WJL\EBFR^?GDBC[KGASVQYIBMXKNS??BDHQJBOEL\FDJTyAUPDNBCC?CACT@@A@`@RWYBAGPCPDG[JDPVCPFSUNPB?AGNNS_@IF@JDHM\NB?@N@MN\W`@ECQB?JOTNYA\OIPNCMAHUF@G]AI^IJOPJ?DCOHUS]?][ICDWGHAHBAMMG?OLNTQUFPDDQC_@QAKFQFUOCNMUU?DF\HIRDKPEIUHQF?HR_@@`@?Y?LLMOJFGFP?S?PXGJROARCO?NN@CC@@P?BRSPE@MCHF[FJ?[@BGGJIDBE?RNEGQEEII??JQ?MFECESC]XEF]_@JRT?\?D\DIGKRNGVECJKJHPGMIA@QRFGD?SQ@V`@TG?RVFN?HGDPHP\LGIWHCGUOI[I^ABT??RSXTD@CMJ[EDLNMC?BDBPM[DY?@H@M?D\H?HANNSJH]TE?GF?DFA@M?RCHVBAF[?DEPSMDZI?AEIS@?UKEDSGMT@?Q?LIFIJPUA[DHBFKC?P[RND?KBL@QDB?S?D?KEV?UHUAX\]MPTABLBP?FKD?GBIXALR?WFIMQE?@IDODI?JXWPE]CR?T?JM?GGGT@QW@JDGIH?EAMSAHJR?XA?FE??JQI]UA?QCDPAC@CUR]\GDAYC?AE?SCKUAFIE?OTXEEB]??DLOI?IJNUUFJ??CLDKG^FCCRSP@AR^Q[L?DLI?UMCCGAUPUANT?HLEG@@?XKGOBFSHR?KCFSJCMHBHSOAATCUCLRUPR??C?@JD@?YDHR?SB@@MCI?MTIYXc@@GIJ?YA??CPPKNU[KMFRA@GMD]JFA?EKJ?AM\HX?DRQNONQEAHGHF@S?HC@MGOKFQIS?EBJA?BI[A_@@??P?QCUHKDFSXPHJE?\CSAHJD^AFDBAN\G@JCIBBKY?DFPT]@KCO\BE?RGFA@HNASB?DQ?PJYNR^R@QNURCLAD?OAQ@CHYO@OEFRUOBMHV?A^?j@\OG_@BYDOL?GLKOL@FBADKBESKXBMAMOFNOJP?LFG^CC@OSE]ACRKF?UQE_@XCDG?[WIKGDLDPC\LCLGXNCUIWBHPPFMVNL?GM\BHCX?OHCFCA\KM?@HG@VE?TNLDMDC?]HIGELJWIRIC]QDA??U?DXE??_@XYFAHK?QSB?HORAEU?@]YDGIG@QQQQQQQQQHQBQIIEIIIIIIIBBBBBBBBBBBBBQ?DAKKEABDNHF\LFVSFTF@@TKBIS?M`@OH?RAREEBAMZZAZBZCZDZEZFZGZHZIZJZKZLZMZNZOZPZQZRZSZTZUZVZWZXZYZZZ[Z\Z]Z^zAL{AN}A_@Z`@Za@Zb@Zc@Zd@Ze@Zf@aBXbBg@Zh@Zi@Zj@Zk@Zl@Zm@x@M|AOv@n@Zo@Zp@Zq@Zr@}@NfB`@y@s@Zt@qBOv@Q_BSZu@Zv@~@P~AR`BTZw@{@YcB[w@x@Zy@Zz@|@Bm@QtBu@yBRZ{@Z|@Z}@Z~@e@_AZ`AdB\Zx@wBz@f@{@zB}@m@n@nBp@oBr@f@aAZbA_C~@e@Z|B]e@g@jBi@lBk@|@m@cC[w@]~@_@gBa@Zs@sB^m@cAZdAZeAZfArBt@jC`@oC^p@gAZhA~B|@{B~@f@iAZjApCa@kCt@lCdAmCfAhC\eB^f@SuBv@z@d@ZkAZlAZmAZnAZoA`Co@ZpAZqAZrAs@kAxCmAzCoAs@e@tCjAcATvB^e@sAZtAs@uAZvA`AwAZxAaAb@fAw@fAUeApA{CrAvCeAnCa@uC^_Df@bA]qChAgA^gD^p@`AdC^hDVz@yAZzAZ{AZ|AZ}AZ~AZ_BZ`BZaBZbBZcBiD[iC^eDqA|C^gABaDvAsD\`AbAbAx@}Bl@}ClAyCnAtDrAaAs@f@dBZeBZfBZgBZhBZiBZjBZkBZlBbDxAuD|@x@mBZnBZoBZpBZqBe@rBZsBZtBeAp@yD^cAu@iAx@wDBeCh@kBj@mBl@vDy@xBl@bEnBcEpB`E^aE}@mE~@xDmAhEv@gEq@dDVzDt@jDzAkD|AmD~AoD`BqDbB`DtAnAoBdEqBoEr@qE{AlD}AnD_BpDaBrDcBrC}@kEz@fDfA{El@pE^wE|ArE_ByEbBnEnAp@uBZvB{@wBZxBZyBZzBZ{B~E}AxE`BtEcBuE^|Ea@hBBbFxBcFzBjAeB{DgB}DiBZ|BZ}BZ~BZ_CqAs@zE~@qAb@rAyBdF{BeF~AsEaBlFt@jA`CZaCZbCZcCZdCiA]mAi@fCl@}EBaFvBmAeCZfCZgCZhCZiCZjCZkCZlCcDBvEpBtF^oF_B_FcBeEsBfEa@`FoAiEy@lEBmFBnFzB`G{B|FqB~FtBy@b@gFfB|DhBkA|BjF~BaGa@pF^uAb@eGBbGgBhFjB_ElB}F`BfGaBgGbBhGcBuFj@jEm@u@hBcG}BkF_C_Gz@uAs@qFaCrFcCmGbCsFdClGt@iGk@nG^kGl@jGiB~DkBoGl@xA|BdG_CrG}BpGBu@mCZnCkAjBqGm@nAoCZpCZqCZrC{FlCtG~BxAjBwAsCZtC{GkBwAcC~GdC}GlBzG_C}@uCZvCZwCZxCZyCZzC|GtCwGpCxGrCdHqCyGkCvFfCwFhCyFjCeHrChHkCiHlC_HvC`HxCbHzCfHgCxFiCzFkCuGnCvGkBu@{CZ|CmHiBiF}BoH|BnH|CpHkBqHlBjHwCaHyCkHhCgHkCrHiClHlCsHjCrA}CZ~CZ_DZ`DZaDZbDZcDZdDZeD?fD</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????A??B??B?????C??A??A?????D??E??@W??F?F??G??P??gH?H??I??P??s@?H??I??@A?OB?J??I??PI?[W?J??K??PL?cY?L??I??@?????M??A??A?????N??E??pA?Cs?O??E??P@?kf?P??Q??@V??F@R??E??@B????S??T??p??sE?U??V??PG?GC?W??V??`B????X??Y??pN?KI?X??Z??PF??J?X??[??@A?CC?\??]??pA?WD?^??A??A?????_??E??pS?WC?`??a??@U?wL?b??c??PJ?sC?b??d??@o?oJ?e??f??@A?SG?e??f??`C?gG?e??g??P??sJ?h??A??A?????U??V??pB?wB?i??j??@C?SF?C??k??PI?ShAl??m??p@?Co?_??E??@M?KC?n??o??@N?KF?n??p??@A?sG?q??A??A?????b??d??@A@sK?b??r??PD??H?S??V??p??kE?s??t??p@????u??v??P?????w??x??@B?__?y??A??A?????W??V??PC????b??z??@W?GN?b??{??pA?gO?`??|??P??WH?}??A??A?????l??m??@C?Co?~???@?PI?wmBX??[??@??CC?\??A??A?????\??]??PF?_D?e??g??`E??K?@@?A@?@D????B@?v??@A????X??Z??@@?wI?C@?D@?P??kd?E@?F@?`B?SE?E@?A??A?????b??d??Pf?cJ?b??G@?`L?sL?X??Z??PC?{I?X??H@?@@?sB?W??V??`A????i??I@?`??kI?i??I@?`N?GG?C??k??`@?SfAb??G@?@T?wL?i??]??@O?[D?X??Z??@B?{I?J@?A??A?????n??p??pB?{G?K@?L@?@@?CU?M@?L@?p@?wI?N@?L@?@??W|?O@?A??A?????b??{??`??cO?\??P@?`N?CJ?Q@?]??`@?GA?b??d??Px?GK?b??R@?pL?_G?n??p??@S?[H?S@?A??A?????X??H@?P??sB?e??P@?@@?[K?n??o??@A?cE?T@?o??P@?GH?T@?U@?`I?CG?V@?W@?pr?kG?V@?X@?`d?OM?T@?Y@?PY?KR?M@?Z@?@A?sL?[@?\@?PA?Ce?[@?]@?@M?Of?[@?^@?@??kt@_@?A??A?????X??Z??@E?{I?`@?a@?`B?kC?b@?c@?P@?Gm?d@?e@?`??G?@f@?g@?`^?[]?h@?i@?`G?oI?h@?j@?`D?[K?k@?l@?PT?G^?m@?A??A?????P??Q??`E?GE@P??n@?pc?WA@o@?p@?@D?OY?q@?r@?`B?gc@s@?A??A?????b??d??pr??K?i??t@?pH?gN?i??u@?@L?CT?b??G@?pM?wL?i??A??A?????b??c??@F?WC?`??f??@A??G?v@?f??pC?CF?w@?x@?@??_X?y@?A??A?????h@?j@?P??KK?z@?{@?P??{P?z@?{@?@??GQ?|@?A??A?????`@?a@?@F?sC?}@?\@?pE?WW?~@?\@?@C?KS@~@??A?`R@og?@A?A??A?????S??V??PC?KF?P??AA?PN?sS@o@?BA?pA?_T?CA?c@?@@?GS?DA?c@?PA?cH?d@?EA?pB?gy?d@?EA?`u?[j?FA?A??A?????f@?g@?Pj?w]?f@?GA?`q?Ka?o@?p@?`@?CY?CA?HA?@@?OV?DA?HA?pD?CI?d@?IA?PD?wz?~@??A?Pe@oh?JA?A??A?????KA?E??pH?_O?LA?MA?@@????`@?NA?pC?wE?}@?OA?@@?{V?~@?OA?@B?{e@PA?A??A?????f@?g@?pe?c]?h@?l@?PC?wL?v@?f??@H?KF?QA?]??p??_@?RA?]??`??{A?SA?]??`??cB?TA?]??`??KC?UA?]??@E?{O?UA?VA?@C?wp?UA?VA?@?????WA?A??A?????</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2591990304;
    let startMs = 1664992930482;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","no_Java_frame","java.lang.String","one.nio.server.AcceptorThread","run","one.nio.net.Socket","acceptNonBlocking","one.nio.net.JavaServerSocket","accept","sun.nio.ch.ServerSocketChannelImpl","implAccept","sun.nio.ch.Net","java.net.Inet4Address","java.lang.Thread","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","ok.dht.test.frolovm.ServiceImpl$1$$Lambda$68.0x0000000800ccc448","ok.dht.test.frolovm.ServiceImpl$1","lambda$handleRequest$0","one.nio.http.HttpServer","handleRequest","RequestHandler0_entityHandler","ok.dht.test.frolovm.ServiceImpl","entityHandler","putHandler","emptyResponse","one.nio.http.Response","<init>","java.lang.String[]","one.nio.server.SelectorThread","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","one.nio.util.Utf8","read","toAsciiString","byte[]","one.nio.http.Request","getPath","substring","java.lang.StringLatin1","newString","one.nio.net.JavaSelector","select","iteratorFor","one.nio.net.Session[]","handleParsedRequest","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","ok.dht.test.frolovm.ServiceImpl$1$$Lambda$68+0x0000000800ccc448","sendResponse","writeResponse","write","one.nio.net.Session$ArrayQueueItem","java.util.Arrays","copyOfRange","java.lang.invoke.LambdaForm$MH.0x0000000800cc8800","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800cdb800","jdk.incubator.foreign.MemorySegment","ofArray","jdk.internal.foreign.HeapMemorySegmentImpl$OfByte","fromArray","parseRequest","stringToSegment","getParameter","ok.dht.test.drozdov.dao.Entry","sun.nio.ch.Util$2","iterator","java.util.HashSet","java.util.HashMap$KeySet","java.util.HashMap$KeyIterator","toBytes","one.nio.util.ByteArrayBuilder","startParsingRequestBody","one.nio.net.JavaSelector$1","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","processEvents","processReadyEvents","add","java.util.HashMap","put","putVal","newNode","java.util.HashMap$Node","ok.dht.test.drozdov.dao.MemorySegmentDao","upsert","java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock","lock","java.util.concurrent.locks.AbstractQueuedSynchronizer","acquireShared","java.util.concurrent.locks.ReentrantReadWriteLock$Sync","tryAcquireShared","java.lang.ThreadLocal","get","setInitialValue","java.lang.ThreadLocal$ThreadLocalMap","set","java.lang.ThreadLocal$ThreadLocalMap$Entry","getTask","java.util.concurrent.ArrayBlockingQueue","take","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","getHeader","trim","one.nio.net.JavaSocket","java.nio.ByteBuffer","wrap","java.nio.HeapByteBuffer","java.util.concurrent.locks.ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter","initialValue","java.util.concurrent.locks.ReentrantReadWriteLock$Sync$HoldCounter","ok.dht.test.drozdov.dao.MemorySegmentDao$Memory","java.util.concurrent.ConcurrentSkipListMap","doPut","java.util.concurrent.ConcurrentSkipListMap$Node","execute","offer","java.util.concurrent.locks.ReentrantLock","java.util.concurrent.locks.ReentrantLock$Sync","acquire","java.util.concurrent.locks.AbstractQueuedSynchronizer$ExclusiveNode","fullTryAcquireShared","lockInterruptibly","acquireInterruptibly","java.util.concurrent.ConcurrentSkipListMap$Index","java.util.concurrent.FutureTask","ok.dht.test.drozdov.dao.MemorySegmentDao$$Lambda$81.0x0000000800ccd550","call","lambda$flushInBg$1","values","java.util.concurrent.ConcurrentSkipListMap$Values","one.nio.net.SocketClosedException","java.net.SocketException","java.io.IOException","java.lang.Exception","java.lang.Throwable","fillInStackTrace","java.lang.Object[]",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
